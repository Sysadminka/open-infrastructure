(c) Thnx to Wacky-Tobaco / Michael Abramovich!

Original article: https://toster.ru/q/215615#answer_583514

Michael, sorry, don't have your contacts to ask for publication.

If any, I'll remove it or change it, please contact at vadim.isakanov@gmail.com

Сначала читаем: https://habr.com/ru/post/208196/

DevOps - не профессия. Это название культуры доставки кода от разработчика (dev) через тестировщиков и до сисадмина(ops) и обратная связь по этой цепочке.

Человека, который внедряет DevOps, обычно называют... как хотят. Чаще всего этим занимается какой-нибудь нон-конформист в команде.

Профессии, которые отрисуются в процессе построения этой методологии следующие:
Build Engineer - инженер, который управляет зависимостями, сборками, конфликтами кода.
Release Engineer - инженер, который управляет репозиторием кода (кто куда и по каким правилам мерджится и откуда бренчуется). Пожалуй, это самая сложная задача в больших проектах. Особенно с нестрогим Agile или в Waterfall.
Automation Engineer - инженер, который занимается автоматизацией рутинных задач. Обычно деплоймент, автотесты, etc. Все эти buzz-слова типа Docker - его инструментарий.
Site Reliability Engineer - инженер, который поддерживает ops (апгрейды, расширение железа)
Configuration Manager - непонятная мне специальность. Жуткое порождение HR-специалистов, давящих на громкое название позиции. Можно было бы пойти дальше и назвать специальность ZooKeeper Vice President

В список не вошла самая главная специальность - "психолог". Человек, который должен следить за людьми и вычислять психологически важные аспекты команды, пораждающие боттлнеки производительности.

Почти всегда все эти роли совмещают один-два человека. Ну это зависит от качества кода.
Назовем эту компанию BRAE/CM для краткости.
Задача BRAE/CM состоит в том, чтобы программный код, который выходит из под пера программистов, оставался на контроле программистов и сисадминов одновременно. Программисты, равно как и сисадмины, благодаря DevOps-подходу, имеют возможность и даже обязаны обслуживать код на протяжении всего жизненного цикла от планирования архитектуры до мусорки.
То есть сисадмины начинают рулить еще до того, как код попадет к ним - на ранних стадиях, а программисты продолжают рулить своими задачами уже после того, как код от них ушел к сисадминам - на поздних стадиях. И все это прозрачно друг для друга и все проблемы и решения ходят туда сюда и не спотыкаются о бюрократия в стиле "ничего не знаю, мы код уже закоммитили, у меня тут свои проблемы, у них сломалось - пусть сами и чинят".

Так вот эта работа - завершающая стадия системного администратора и начинающая стадия разработчика. Поэтому не бывает Junior BRAE/CM.
BRAE/CM бывает всегда только Senior в системном администрировании и всегда Junior в программировании.

Еще один момент. В домашних условиях можно выучить инструменты на базовом уровне. Но не поварившись в одной кастрюле с реальными разработчиками, смысл всей этой кухни не понять. Так что сразу забейте. Но если хотите, могу описать пошаговый длинный путь как стать RE/CM:

Сразу оговорюсь по языкам.
У каждого языка свое предназначение. Java чаще используется в корпоративном секторе. Там много серверов и сложные бизнес-приложения. Поэтому Java-мир очень чувствителен к таким понятиям, как "технинческий долг" и "управление процессом разработки". И именно поэтому именно там все основные вакансии DevOps и именно там будет самый интересный опыт.
Кроме Java, традиционно сильная DevOps-культура у Ruby. Практически все остальные языки не имеют столь развитой и популярной инфраструктуры в в данном контексте и потому вам скорее всего будут неинтересны.
Другими словами, если в среде разработчиков выбор языка - тема для холивара и эмоций с миллионами сравнительных анализов с противоположными результатами, то для специалистов по DevOps выбор очевиден и прозрачен. Java - это одновременно самые интересные задачи, самый богатый toolset, самый большой выбор вакансий и самые высокие зарплаты.

Каждый последующий пункт, кроме особо длинного первого, будет выливаться в неделю-две достаточно плотного труда. Если не прокрастенировать и уделять этому по несколько часов вечером.

Итак, что делать:
1) Почитать книги Head First по Java. Пройти курсы Java на EDX.
2) Освоить SVN. Есть прекрасные тьюториалы. (GIT освоим позже)
3) Поставить VirtualBox (не VMWare!!!)
4) Написать простенькое приложение. Код коммитить в SVN. Собирать его при помощи maven.
5) Поднять на отдельной виртуалке Jenkins. Он должен брать код приложения на SVN и запускать свой локальный maven для сборки.
6) Написать модульные тесты (unit tests) своего кода. Пусть maven и их прогоняет.
7) Поднять где-нибудь Nexus. Усложнить задачу maven, чтобы он теперь складывал все в Nexus. Если maven'у потребуются внешние библиотеки, он тоже не сам должен ходить в интернет, а через Nexus (Central repo).
8) Настроить на своем десктопе vagrant так, чтобы он с нуля создавал виртуалки VirtualBox.
9) Создать виртуалку DEV через vagrant. При этом ansible должен на ней что-нибудь настроить (например установить JDK)
10) Научиться деплоить jar/war из Nexus на виртуалку DEV чем-нибудь. Чем - не посоветую, так как сам работаю с очень сложным IBM uDeploy, а это точно не для новичка. Посмотрите в сторону Rundeck или чего-то такого. Может самим Jenkins'ом задеплойте.
11) Напишите интеграционные АВТОтесты. На чем хотите (как вариант: Selenium).

Усложняем систему.
12) Донастраиваем Jenkins: собирает maven-проект; выкладывает на Nexus; дергает vagrant/ansible для создания виртуалки SIT (system integration test); деплоит приложение на SIT; прогоняет автотесты на SIT; удаляет виртуалку после успешного завершения автотестов.
13) Прикручиваем SonarQube в Jenkins для статического анализа кода. Исправляем косяки своего кода, согласно полученным от SQ рекомендациям.
14) Прикручиваем мониторинг Sensu.
15) Пишем нагрузочные тесты на чем-нибудь. В идеале потрогать два инструмента: jMeter и Gatling.
16) Как и в 12-м шаге прикручиваем в Jenkins автоматизацию создания виртуалки SLT (Stress/Load test) и прогона на ней тестов. Только уже лоад-тестов(обязательно) и стресс-тестов(опционально) соответственно.
17) Дописываем в свое приложение какой-нибудь функционал, чтобы использовалась база.
18) Придется познакомиться с LiquiBase. Деплой SQL руками делать запрещено.
19) Перейти на Docker (то есть теперь приложение выкладывать не напрямую в ОС, а внутрь докера)

20) Денек на то, чтобы почитать про Agile, Scrum, Waterfall и прочие организационные порядки.

А теперь немного уходим в управление проектом:
21) Поставить Atlassian Jira. Разобраться, чем отличаются Epic, Story, Task, Sub-Task. Создать себе подобной этой структуре фронт работ (делать его не придется, просто нафантазируйте).
22) Поставить Atlassian Stash и связать его с Jira.
23) Переехать со своего SVN на GIT, предоставленный Stash'ем.
24) Пройти Git-тьюториал какой-нибудь. Инструмент очень нетривиальный.
25) Взять любую таску в работу. При этом в начале работы сделать новый Git branch из тикета Jira.
26) По завершению работы запустить всю построенную ранее цепочку, но уже для своего брэнча.
Дайте попробую угадать: вам пришлось скопировать все джобы и переписывать в них ветки?
27) Сделать джобы нормально. Чтобы одни и те же можно было использовать для любых веток - по аналогии с принципом программирования "reuse code". У Вас будет reuse job :)
28) Сделать pull request, самому сделать code review и самому себя же за-approve'ить. После этого сделать merge своей ветки в master.
29) Сделать сборку брэнча автоматической по git-hook (или SCM pool)

30) А теперь высший пилотаж: к чертям Docker, Copistrano и прочую buzz-word-hipsters-галиматью. Теперь вы с этим знакомы и сможете применить, но пришло время выгрызать этот детский сад калёным железом. Теперь вы доставляете код только как .deb-пакеты. Это значит, что вы:
a) разбиваете control-файл на несколько пакетов, возможно с lib*,
b) оверрайдите все ~20 dh_ в файле rules так, чтобы все это соответствовало вашим наработкам в предыдущих пунктах.
c) раскидываете файлы по .install
d) самое тяжелое: готовите .preinst, .postinst, .prerm, .postrm файлы СОГЛАСНО ИХ ПРИМЕРАМ .ex, сгенерированным dh_make - то есть с разбиемнием на update/configure/broken-install и что там еще есть. Это означает, что при переустановке, при апгрейде, при даунгрейде, при удалении и при пурдже, у вас будут разные сценарии, каждый из которых должен быть проработан досканально. На этом этапе вы также познакомитесь с понятием "регрессионные тесты".

Ну как бы базовый вариант вот. Но это далеко не весь инструментарий и путь. Это так, для начала.
Кроме этого неплохо бы познакомиться с Puppet (это не очень подходит для DevOps, скорее для рядовых админов с кучей серверов, но это очень популярный инструмент ввиду того, что никто не понимает, что такое DevOps и вас скорее всего заставят управлять сотней серверов, вместо релиз инжиниринга). А так же нужно познакомиться с операционными системами NixOS (обязательно) и CentOS/Debian (опционально, но я бы палкой бил тех, кто не знает эти OS). Кроме того, надо базово ориентирваться в PostgreSQL.

Внимание, важный момент, который должен быть вшит на уровень подсознания у DevOps-ориентированного инженера: вы все время пробуете новые инструменты. Вы всегда будете находить что-то очень отличное. Знаете Nexus как свои пять пальцев и он решает почти все проблемы? Отлично! Теперь выкидываете Nexus и ставите Artifactory. Знаете хорошо CentOS? Круто! Теперь пробуете все это проделать на Windows или Debian. Потому что только когда вы сможете сравнивать инструменты, ваша работа будет ювелирной. А DevOps бывает либо ювелирным, либо он не DevOps. Вы должны быть языко-независимым, платформо-независимым и инструменто-независимым.

Что будет дальше? Дальше вы начнете работать с микросервисами (сотни одинаковых контейнеров в облаке, которые должны как-то работать друг с другом без ручной конфигурации). Тогда познакомитесь со всякими Consul, ZooKepper и кучей инструментов AWS/OpenStack.

