(c) Thnx to Wacky-Tobaco / Michael Abramovich!

Michael, sorry, don't have your contacts to ask for publication + your blog on blogspot with that article is already deleted, so please forgive me that I just publish that just like that.

If any, I'll remove it or change it, please contact at vadim.isakanov@gmail.com

# Как стать системным администратором

Созрел я наконец для этой статьи. Навеяна она тем, что мне частенько приходится готовить своих друзей в системные администраторы. Каждый раз я придумываю им задачки и каждый раз заново придумываю, что же придумать. Пришло время дать начало полноценному мануалу.
В отличии от подобных, кстати очень интересных, статей, свою я напишу в форме тьюториала - достаточно атомарных шагов, которые усложняются от раза к разу. То есть пройдя по нему от начала и до конца, можно будет искать работы на деньги, сопоставимые со средней зарплатой в вашем городе, а может и побольше. При этом на собеседовании чувствовать себя очень уверенно. Те, у кого хватит терпения, могут использовать этот курс, как базу перед началом курсов о программировании. Очень удобно начинать программировать, когда уже хорошо ориентируешься в нижнем слое операционной системы. В конце будет также дана ссылка на мою короткую статью на тостере, о том, куда дальше двигаться, чтобы стать DevOps'ом.

Немного вводной информации для новичков. Какие администраторы бывают, сколько они зарабатывают, каковы их карьерные перспективы.

### Итак, какие администраторы бывают:
1) Универсальный администратор - администратор, который управляет операционными системами и сервисами на них (кроме совсем уже сложных сервисов, на которые есть собственные администраторы - см.п.2). Основные системы, с которыми работает системный администратор: Linux, Windows Server, Sun Solaris, BSD. Есть и менее популярные системы, на которые также требуются специалисты (они дороже, но предложений мало).

2) Узкопрофильный администратор сервиса (баз данных, кластеров, сетей, VoIP, MS Exchange и т.д.) - узкоспецилизированный администратор, заточенный на конкретные глубокие задачи. Как правило, все они бывышие универсальные администраторы, которые решили сосредоточиться на чем-то одном.

3) Build/Release-инженеры [иногда называют Configuration manager'ы] - бывшие системные администраторы, которые ударились в программирование и занимаются настройкой движения программного кода от IDE разработчика до сервера, на котором он будет работать. В это движение входят статический анализ кода, модульное тестирование, компиляция кода, упаковка программы, интеграционное/системное/регрессионное тестирование, выкладывание в репозитории и установка на серверы. Одним словом Continuous Delivery.
Как правило, это уже вершина карьеры системного администратора. В такие инженеры попадают только самые сильные и матёрые. И таких не более 5%.
Отдельно хотелось бы упомянуть, что стиль работы регулируется не только объемом технических знаний, но и "культурным" подходом, который называется DevOps. Заключается он в полной прозрачности процесса как для Developers (разработчиков) так и для Operations (системные администраторов). Причем не просто прозрачности, а качественной связи в обратную сторону тоже.
Основные инструменты, которые используют B/R-инженеры:
VCS (например Git, Mercurial, SVN, ...)
SCA (SonarQube, Veracode, Moose, ... )
Maven, Ant, Gradle, Rake, make, SCons, WAF, NuGet, ...
CI (например Bamboo, Jenkins, TeamCity, TFS, ...)
CD (например uDeploy, RunDeck, ...)
EM (например Vagrant, Docker, ...)
CM (например Ansible, Puppet, Chef, CFEngine, SaltStack, PowerShell DSC, ...)
Репозитории (например APT, YUM, Nexus, Artifactory, Archiva, Chocolatey, ...)

____

### Теперь углубимся только в первый пункт, потому что статья ради него написана.
Как я уже оговорился, операционных систем много и, как правило, каждый системный администратор выбирает себе систему по душе. Мы же будем говорить только о Linux. Не холивара ради объясню почему.
Windows - бесспорно прекрасная система. Во многих отраслях она лидирует так, что за ней в принципе невозможно угнаться (тот же Exchange ушел лет на 10 вперед от Zimbra и ее альтернатив). Но:
1) Windows на пушечный выстрел не подпускают туда, где нужна надежность, скорость и прозрачность процессов - то есть к деньгам. Все до единого промышленные системы построены на Linux. Даже мосты в Петербурге разводят на нем же.
Например у крупного сотового оператора это выглядит так: на компанию 10k компьютеров с Windows (в качестве десктопов сотрудников и AD/почты) и порядка 400-500k промышленных серверов на Linux (обслуживают звонки абонентов - от OSS/BSS до биллинга). Понятно где вакансий больше?
2) Windows вообще не держит нагрузку :( Почти не кластеризуется нормально и не тюнится. И я это говорю не как дилетант, а как бывший ведущий специалист по Windows в Мегафоне.
3) Этой системе не повезло в том, что заточена она под офисную инфраструктуру. Занявшись Windows, Вы получите не только интересные сервисы от талантливых парней из Редмонда, но и полный набор коллег в виде нервозных бухгалтеров и недемократичных менеджеров, неспособных сформулировать не то что задачу, но даже собственные мысли. Работа в таком коллективе скорее сделает из Вас профессионала по подковерным интригам, чем системного администратора.
 В мире Linux/Unix все совсем по другому. Вход намного "дороже". Так просто не стартанешь, как в мире Windows, но зато, если стартанешь, выигрыш больше. Коллектив - все такие, как Вы. С уровнем интеллекта компьютерщиков, а не вопиюще тупых гуманитариев. Кроме того, Linux - открытая система, ее принципы понятны почти сразу и работает она прозрачно. Даже если захотите потом вернуться на Windows, Вы будете понимать его лучше, чем те, кто не прошел Linux-школу.

И все же главная выгода Linux от Windows, то что среди их команды попадаются вот такие девчонки!
Вот доказательство:





Базовых видов Linux всего 3: Debian, RHEL и Slackware. Все остальные названия, которые Вам приходилось слышать - это их дочерние варианты (например Ubuntu произошел из Debian).
Каждая из этих систем имеет свой набор плюсов и минусов, которые сводятся к тому, что под каждую задачу надо выбирать свой вариант. Все они имеют право на жизнь и все они по разному хороши. Но для начала лучше выбрать что-то одно. Переключиться потом будет очень просто. Мы будем работать на Debian.

Вкратце о деньгах: хороший специалист стоит дорого. Зарабатывать на этой специальности в 4 раза выше средней зарплаты при трехлетнем опыте в среднестатистическом российском городе-миллионнике вполне несложно. Есть кто работает и за 10 средних зарплат - но этого достигнут только самые трудолюбивые. Те, кто будет жадно пожирать новые технологии, соблюдать культуру (в том числе ITIL и DevOps) и никогда не задерживаться на работе более года. Потому что основная масса опыта идет только в первые месяцы работы и очень важно не почевать на лаврах, а вовремя уйти в другую команду, чтобы опять попасть на волну. Но за эти деньги вы полностью распрощаетесь с личной жизнью.

Последний важный момент: английский язык. Если его нет хотябы в зачаточном виде - до свидания. В мире ИТ делать без английского в принципе нечего. Английский на столько является само собой разумеющимся, что о нем даже не спросят на собеседовании и его не указывают в резюме. Так что либо марш учить, либо конец Вашей непостроенной карьере. В конце концов, давайте будем откровенны: на что вообще способен человек, который даже не может выучить иностранный язык? Мало на что.

Итак, в бой. Под катом уже пойдет последовательность действий.



План будет прост. Мы пройдемся по большинству технологий. По каждой технологии я буду ставить задачу, а Вы решать ее, тем самым открывая себе черные пятна на карте Linux и получая опыт методом набивания шишек.

Нам потребуется только один компьютер с Windows (любой версии) и минимум 4Gb оперативной памяти (RAM).

Ответы на задачи надо искать в Google. Их также можно спрашивать у меня - я очень охотно отвечаю.


### НАЧАЛО НАЧАЛ ТУТ

Задача #1:
1) Скачать и установить на Windows программу VMware Workstation. Она платная, но кто не сильно брезгливый - добро пожаловать на торренты. Подойдет любая версия.
2) Разобраться с терминами: хост-машина, гостевая(она же виртуальная) машина.

Задача #2
1) Скачать где угодно дистрибутив Windows (любая версия) в качестве .iso-образа
2) Создать гостевую машину (CPU:1, RAM: 1Gb, HDD: 20Gb). В качестве CD-rom подцепить файл с расширением .iso
(ВНИМАНИЕ: в мире IT не принято называть серверы согласно операционным системам, которые там установлены типа "Win2012R1", потому что ОС может меняться достаточно часто и не отображает смысл существования сервера. Старайтесь выбирать умные названия, из которых понятно, для чего создан сервер, какие цели он обслуживает. И обязательно номеруйте. Например: SysAdmStudy1)
3) Запустить виртуальную машину так, чтобы было видно, что Вы загрузились с виртуального CD-rom'а, в который вставлен виртуальный диск (который является файлом с расширением .iso).
4) Установить Windows на виртуальную машину.

Задача #3
1) Выключить виртуальную машину (power off)
2) Экспортировать виртуальную машину в образ .OVA
3) Создать новую виртуальную машину на основе этого образа.
4) Запустить обе виртуальных машины и убедиться, что они нормально стартуют.

Задача #4 (очень сложная, но ее не обойти)
1) Выяснить что такое ping и глагол "пинговать". Попробовать попинговать адрес 127.0.0.1
2) Запустить команду cmd на каждом из трех компьютеров (две виртуалки и хост-машина) и в ней выяснить какие адреса у этих машин.
3) Настроить сетевые интерфейсы обоих виртуальных машин и конфигуратора сетей VMware так, чтобы хост-машина могла пинговать обе виртуалки и каждая из виртуалок могла пинговать вторую.
4) Убедиться, что виртуалки могут пинговать внешние адрес (например 8.8.8.8). Если нет - починить.

Задача #5
(ремарка: Windows нам нужен был только для того, чтобы настраивать сеть на знакомой операционной системе)
1) Скачать операционную систему Debian на DVD (только перый диск, остальные не нужны). Я специально даю 32-битную версию, потому что она пойдет везде.
Все диски качать не надо. Хватит только первого. 
2) Переустановить операционную систему на первой виртуалке с Windws XP на Debian.
ВНИМАНИЕ:
Во время установки все языки и локали указывать только английские (по умолчанию). Никакого русского языка не допускается (потом намучаетесь с кирилицей). Когда дойдете до разметки диска - делайте автоматическую.
Имя сервера задать таким, чтобы было видно, что он перый (например server1).
На этапе выбора сервисов выбирать только два: базовые утилиты (самое нижнее, если память не изменяет) и SSH-сервера (третье снизу).
Ни в коем случае не выбирать GUI (убирается на стадии выбора компонентов нажатием пробела). Никакой графики и рабочих столов даже близко на сервере быть не должно! Если очень хочется, то стисните зубы и все равно галочку снимите. Поставите - и конец Вашему обучению, это я гарантирую.
Загрузчик Grub надо устанавливать, когда будет такой вопрос.
3) При перезагрузке убедиться, что грузитесь с виртуального диска, а не виртуального CD-rom'а с .iso-файлом.

Задача #6
1) В черном экране набрать логин root и пароль, который давали при установке (символы даже звездочками не будут отображаться, не будет понятно печатаете или нет - привыкайте).

2) Перейти в директорию /var. Дать команду, показывающую, в какой Вы сейчас директории.
3) Прочитать ману по команде ls . Все читать не надо - только основное положение и о флагах -l, -t, -r, -A
4) Отобразить список директорий и файлов так, чтобы по каждому файлу/директории были подробные данные (тип, права, владелец, дата изменения, размер, имя).
5) Остановить взгляд на любой из строчек и слева на право объяснить что значит каждый символ.
6) Перейти в директорию /var/log без упоминания слова "var" в команде (то есть задать путь, относительно текущего).
7) Перейти в директорию /var/ без упоминания слова "var" в команде (то есть отойти на директорию назад относительно текущей).
8) Создать директорию /tmp/lesson/
9) Перейти в директорию /tmp/lesson, задав абсолютный путь (от корня).
10) Создать там файл под названием hello.txt
11) Сменить права на файл /tmp/lesson/hello.txt на следующие: 0777

12) Попробовать попинговать внешний адрес 8.8.8.8
      Если не пингуется - решить проблему (возможно будет очень тяжело).

Задача #7
1) Скачать и установить программу Putty. Запустить ее.
2) Посмотреть какой IP-адрес у виртуалки.
3) В программе Putty подключиться по SSH на этот IP-адрес и далее работать с системой только через SSH.

Задача #8
1) При помощи команды cat отобразить содержимое файла /etc/apt/sources.list
2) Так же при помощи команды cat и перенаправления в файл (символ ">"), записать в этот файл новые данные (это действие перетрет все, что там было раньше):


Для Debian 8 Jessy:
`# DEBIAN JESSIE ###########################################################

## Debian Jessie base:
deb http://ftp.debian.org/debian/ jessie main contrib non-free
#deb-src http://ftp.debian.org/debian/ jessie main contrib non-free

## Debian Jessie security updates:
deb http://security.debian.org/ jessie/updates main contrib non-free
#deb-src http://security.debian.org/ jessie/updates main contrib non-free

# Debian Jessie updates:
deb http://ftp.debian.org/debian/ jessie-updates main contrib non-free
#deb-src http://ftp.debian.org/debian/ jessie-updates main contrib non-free`

3) Обновить кэш менеджера пакетов apt-get
4) При помощи команды apt-get установить пакет vim

Задача #9
1) Командой vi открыть на редактирование файл /tmp/lesson/hello.txt
2) Проматериться. Потратить пол часа, чтобы хотя бы выйти из этого полоумного редактора - знакомьтесь, он с Вами теперь на всю жизнь как брат родной будет.
3) Пройти тьюториал по vi или vim
4) Еще раз повторить пункт 1) из этой задачи
5) Написать любой текст на 40-50 строк в файле /tmp/lesson/hello.txt. Одно только условие - в любых двух-трех строках на выбор должны быть буквы abc (именно строчные и именно в этой последовательности). Например так: "sdlsfjvnd lfvj ndsflvabcerf". Сохранить и выйти.
6) Отобразить содержимое файла командами cat, а потом less.
7) Отобразить только последние 10 строк файла. Отобразить первые 7 строк файла.
8) Подсчитать количество строк в файле (естественно не вручную)

Задача #10
1) Немножко погуглить, что такое конвеер. Что таке "пайп" ("pipe") - вертикальная черта.
2) Отобразить содержимое файла /tmp/lesson/hello.txt , и вывод перенаправить по конвейеру в подсчет строк.
3) Отобразить содержимое файла /tmp/lesson/hello.txt , и вывод перенаправить по конвейеру в программу grep, задача которой отсечь все строки, кроме тех, которые содержат текст abc (то есть в результате должно вывалиться в консоль не 20 строк, а только 2).
4) Все то, что сделано в предыдущем пункте отправить дальше по конвееру в подсчет строк.
5) Отобразить содержимое файла /tmp/lesson/hello.txt , и вывод перенаправить по конвейеру в программу grep, задача которой отсечь все строки, кроме тех, которые НЕ содержат текст abc (то есть в результате должно вывалиться в консоль не 20 строк, а только 18).

Задача #11 (Внимание: в этой задаче запрещено гуглить. Будем привыкать к манам.)
1) Прочитать ману по  команде shutdown. При помощи этой команды выключить виртуалку (команды init или halt использовать пока запрещено).

Задача #12
1) Убедиться, что обе виртуалки выключены.
2) Склонировать диск первой виртуалки на вторую.
3) Запустить только вторую виртуалку. После запуска также войти под пользователем root
4) Сменить ей название на такое, которое будет показывать, что это именно вторая виртуалка (например server2). Изменения отобразятся только после перезагрузки. Внимание на файлы: /etc/hostname, /etc/hosts
5) Командой shutdown рестартануть сервер.

Задача #13
1) Стартануть server1 (так как server2 уже стартован).
2) Зайти через консоль (а не на SSH через Putty) на каждый из них и посмотреть как у обоих IP-адреса. Они должны быть разные.
3) Немного почитать про IP адреса (только IPv4, а не IPv6) и про маски подсети. Познакомиться поверхностно с DHCP.
4) Так как эти адреса были получены динамически (от сервиса DHCP, расположенного на хост-машине с Windows), то ожидаемо, что рано или поздно они поменяются и Вы потеряете доступ к этим серверам. Поэтому теперь пришло время вписать их в конфигурационный файл сети на обоих виртуалках. То есть задача: сделать на обоих виртуалках статически прописанный IP-адрес+маску+шлюз.
5) Рестартануть обе виртуалки при помощи команды shutdown.
6) Убедиться, что с хост-машины пингуются обе виртуалки. Если нет - починить.
7) В Putty сохранить настройки сессий для обоих виртуалок, чтобы открывать к ним подключение в один двойной клик.
8) Выключить виртуалку server2 - она нам теперь не скоро понадобится.

Итак приступим к повседневным задачам системного администратора.

Задача #14
1) Создать переменную в командной строке и присвоить ей значение. Например a=12345
2) Отобразить эту переменную так, чтобы увидеть ее значение.
3) Сделать так, чтобы эта переменная сохраняла свое значение после рестарта системы - найти в какой файл ее вписать, а затем рестартануть виртуалку и проверить сохранила ли эта переменная свое значение командой echo $a.
4) Отобразить переменную $PATH. Объяснить что она значит и что в ней за данные. Сформулировать, что такое переменное окружение и разобраться, откуда оно берется при логине пользователю в систему.
5) Изменить переменную $PATH так, чтобы к существующим путям добавился еще один: /tmp

Задача #15
1) Разобраться как написать простейший скрипт на языке BASH и что такое sha-bang.
2) Написать пустой скрипт, который ничего не будет делать, а только запускаться и завершаться. Расширение скрипта должно быть .sh (например: my_first_script.sh ).
3) Запустить этот скрипт. Учесть подводные камни: права на исполнение, относительный путь к скрипту.
4) Изменить переменную $PATH так, чтобы скрипт можно было запускать просто написав его название без указания пути.

Задача #16
1) Изменить свой скрипт так, чтобы он:
а) инициализировал переменную DATE и присваивал ей значение текущего времени
б) выводил эту переменную на экран
2) Изменить свой скрипт так, чтобы он вместо вывода на экран он создавал файл одноимённый дате в директории /tmp (например /tmp/2013-07-19.txt)
3) Добавить в скрипт функцию, которая после создания файла (из предыдущего пункта) записывала в этот файл строчку "This file has been created at ВРЕМЯ_СОЗДАНИЯ".

Задача #17
1) При помощи CRON сделать исполнение нашего скрипта раз в минуту. Через 10 минут проверить - в директории /tmp должно быть 10 файлов с датами.
2) Догадаться почему же все-таки не 10, а всего один файл там находится. Где допустили ошибку?
3) Создать еще одно задание, которое при помощи команды find будет раз в 10 минут проверять эту директорию и удалять все файлы старше 17 минут.

Задача #18
1) Создать пустой файл abc.txt и вписать в него любую билеберду из букв
2) Скопировать файл abc.txt в xyz.txt с сохранением прав и владельца (сразу так копировать, а не потом менять, см. man cp)
3) Сравнить чексуммы этих двух файлов.
4) Изменить содержимое любого из двух файлов. Сравнить чексуммы еще раз и увидеть разницу.

Задача #19
1) Создать пользователя test. Задать ему пароль отдельной командной.
2) Сформулировать зачем нужны файлы /etc/passwd, /etc/shaddow, /etc/group. Объяснить почему во втором поле в /etc/passwd вместо пароля стоит звездочка (астериск).
3) Написать бэкапный скрипт, который будет:
а) если нет файла /tmp/passwd.backup, копировать /etc/passwd в /tmp/passwd.backup
б) если файл /tmp/passwd.backup уже существует, то сравнивать его с исходным /etc/passwd - если различаются, то копировать, если нет, то завершать работу скрипта.
Как проверить:
Менять файл /etc/passwd нужно созданием и удаленимем любого пользователя. Дату изменения любого файла смотреть командой stat или ls.

Задача #20
1) Установить вэб-сервер Apache2 на виртуалку при помощи менеджера пакетов apt-get.
2) Зайти с браузера хост-машины на IP-адрес виртуалки и увидеть приветствие Апача.
3) Перевесить Апач на порт 8080
4) Повторить второй пункт, но с указанием порта (все там же в адресной строке браузера)
5) Вернуть порт на место. Проверить открывается ли заглушка Апача на стандартном порту (без его указания)
6) Создать три домена в файле hosts (который на хост-машине): a1.com, b2.com, c3.com, указав для каждого из них IP-адрес виртуалки с Апачем
7) Проверить правильность настроек командой ping a1.com (и так для каждого домена).
8) Зайти на эти три сайта, написав их в адресной строке браузера вместо IP виртуалки - нужно увидеть старое знакомое приветствие Апача.

Задача #21
1) Создать директории /var/www/a1.com, /var/www/b2.com, /var/www/c3.com
2) В каждой из этих директорий создать пустой файл index.html
3) В каждом из index.html файлов написать имя сайт и какой-нибудь текст (например: "Hello, this is a1.com")
4) Для каждого из трех сайтов создать виртхосты так, чтобы на каждый из них открывалась не общая заглушка /var/www/index.html, а его личный сайт из его директории, которая была создана в первом пункте.

Задача #22
1) Переименовать файл index.html в index.php со следующим текстом внутри:


<?php phpinfo(); ?>
2) Открыть и увидеть ошибку Апача. Далее маленькая ремарка: Апач умеет отдавать только те файлы, которые можно отдать браузеру как есть, без изменений. Например картинку, mp3-файл или index.html (это просто текстовый файл, который был отдан как есть). Теперь мы уже просим его отдать нам файл, который нужно сначала обработать на стороне сервера интерпретатором языка, на котором он написан (в данном случае PHP) до состояния тестового файла,  уже потом отдать нашему браузеру. Этот процесс называется "захэндлить файл" (handle - удерживать), то есть удержать его для обработки, обработать, а уже потом отдать. 
Теперь сама постановка задачи: через apt-get установить и активировать модуль Апача mod_php. А также в конфиге этого модуля вписать инструкцию для Апача, что все файлы с расширением .php обрабатывать этим модулем (очень похожий пример как это делается, только для Python, а не для PHP, есть тут но ВНИМАНИЕ: команду tee не выполнять, а то перетрете файл /etc/apache2/mods-available/php5.conf, который и так есть, в отличии от питоновского варианта).
3) Настроить такие же модули для Perl и Python. Индексные странички b2.com и c3.com перевести на index.pl и index.py соответственно. (и написать там простешие приветствия на соответствующих языках).


Задача #23
(далее работаем только с одним a1.com. Нам понадобятся некоторые базовые нывыки программирования на паре языков. Вообще администраторы должны уметь писать код, как программисты. Но языки бывают двух типов: те, которые нужны самому сисадмину для решения его задач (обычно Python либо Perl) и те, на которых пишут программисты, для которых сисадмин настраивает серверы. В большинстве случаев это PHP и Java, потому что у этих языков низкий порог вхождения и потому даже senior-программисты, как правило, неграмотны в вопросах всего, что за пределами их технологий. Именно поэтому такие разные языки неожиданно оказались в одном списке :) С программистами Python или Ruby, сисадмин скорее всего встретится уже на вершине карьеры, потому что в этом мире очень грамотные программисты и им не нужна помощь в администрировании до момента, пока не понадобятся всякие сложные кластеры и прочие радости современных технологий. Ну а с небожителями программистами C/C++/D встретиться вообще не суждено - они иногда знают систему лучше многих сисадминов и помощь убогих им не требуется. Итак один день мы убьем на то, чтобы стать быдлокодерами как PHP-программисты - самые основы только. Но конце этого курса вы еще будете вполне сносно писать на Python)
1) Пройти тьюториал HTML отсюда (только раздел HTML Basic).
2) Пройти два тьюториала (раздел PHP Basic из этого и раздел Гостевая Книга из этого)

Задача #24
1) Установить mysql-server
2) Подключиться через командную строку к MySQL-серверу при помощи команды mysql
3) Создать базу данных mydatabase и пользователя myuser
4) Пройти раздел SQL Basic этого тьюториала.
5) Установить Joomla на a1.com и Wordpress на b2.com

Задача #25
1) Прочитать, что такое реверс-прокси.
2) Установить Nginx, который будет слушать 80-й порт и транслировать все запросы к Apache'у, который будет слушать запросы от Nginx на порту 8080.
3) Проверить сайт a1.com. Удостовериться, что access.log Nginx'а пополняется при обращении к сайту.
4) Сделать так, чтобы Nginx транслировал не все подряд дальше по цепочке, а файлы с рашнирением .jpg и .png отдавал сам, а все остальное передавал Apache'у.

Задача #26
1) Включить второй сервер, которвый выключили в 8-м вопросе 13-й задачи.
2) Собрать MySQL Cluster между двумя серверами (NDB).
3) Создать базу данных, на которой будем тестировать работу. В ней создать любую простенькую таблицу и заполнить ее чем-нибудь.
4) Для проверки сделать изменения в одном, а проверить их на втором сервере.
5) Сэмулировать аварию - выключить второй сервер, искурочить файлы базы руками так, чтобы невозможно было восстановить. Например накатить в них "нуль".
6) Восстановить вторую ноду так, чтобы база восстановилась и опять была в кластере. Проверить как в 4-м пункте.

Задача #27
1) Выключить оба сервера.
2) Добавить каждому серверу еще по одному диску на 700Mb каждый (размер специально произвольный, чтобы легче было находить).
3) Включить оба сервера
4) Командой fdisk увидеть оба своих диска и как какой размечен (/dev/sdb на 700Mb должен быть еще не размеченным, без партиций)
5) По DRBD соединить два диска обоих серверов так, чтобы при записи файла на диск первого сервера, результат был виден на втором сервере. Оба диска должны быть смонтированы в /mnt/drbd-disk (директорию естественно не найдете - ее надо создать самому).

Задача #28
1) Выключить опять первый сервер.
2) Добавить еще два диска по 200Mb каждый
3) Включить сервер
4) Командой fdisk отобразить структуру своих дисков. Там должен быть sda - основной диск, с которым Вы работали, sdb - диск по DRBD и два диска sdc/sdd, которые пока неразмечены
5) Соединить sdc и sdd в RAID-массив при помощи утилиты mdraid.
6) Командой cat /proc/mdstat отобразить структуру RAID-массива.
7) Смонтировать диск /dev/md0 в /mnt/raid-disk

Задача #29
1) Теперь выключим второй сервер
2) Добавить диск на 2Gb
3) Включить сервер обратно
4) На новом диске (sdc скорее всего) настроить LVM и смонтировать его в директорию /mnt/lvm-disk1
5) Уменьшить размер диска LVM (lvreduce) вдвое и на освободившееся место создать еще один такой же.
6) Смонтировать оба диска в /mnt/lvm-disk1 и /mnt/lvm-disk2 соответственно.


Задача #30
1) Снести пакет exim4-config, если он установлен.
2) Поставить postfix
3) Настрить так, чтобы почта с сервера выходила наружу, например на ваш ящик в Gmail (не забудьте, что она может упасть в папку Spam - это нормально). Проверять хождение почты надо командой swaks.

Задача #31
1) На первом сервере поднять Nagios
2) Настроить в этом Nagios мониторинг обоих серверов (размер диска, MySQL, количество использованной памяти)
3) Сделать нотификацию на свой e-mail в случае проблемы. Проверять выключением MySQL например.
4) Посмотреть командой netstat -plunt какой порт слушает MySQL и закрыть этот порт фаерволом (iptables) так, чтобы первый сервер думал, что MySQL сломался и не отвечает.
5) Убедиться, что после включения фаервола, мониторинг начал сигнализировать на почту о недоступности MySQL.
6) Удалить правило iptables закрывающее порт MySQL и убедиться, что Nagios сообщил на почту, что работа сервиса "восстановлена".

Задача #32
1) На втором сервере поднять SVN-репозиторий под названием scripts.
2) Сделать его доступным на любом порту через svnserve.
3) Склонировать его на первом сервере в директорию /opt/scripts/
4) Склонировать его же на хост-машине (Windows) в директорию D:\scripts

Задача #33
ВНИМАНИЕ: скрипт, о ктором далее идет речь, надо писать в vi и там же его пробовать выходя из vi и править заходя обратно. НЕ НАДО писать в виндовом блокноте, а потом пробовать в vi.
1) На первом сервере написать скрипт /opt/scripts/backup.sh, который будет в цикле обходить все три сайта (a1.com, b2.com, c3.com из задач 20/21) и будет делать:
a) паковать директорию с файлами сайта (например /var/www/a1.com) в формат tar + сжатие gz
b) снимать MySQL-дамп базы сайта в формате .sql
c) складывать обе этих добычи в папку /var/backups/www/имя_сайта
d) проверять консистентность обоих файлов.
e) переходить к следующему сайту.
f) по завершении всех трех сайтов, скрипт должен отправлять отчет на почту о проделанной работе (размер каждого из бэкапов и сообщение, что консистентность проверена).
2) Закоммитить скрипт в репозиторий

Задача #34
1) Проапдейтить SVN-репо с Windows -он должен увидеть, что в репозитории второго сервера появился новый файл и стащить его к себе в D:\scripts
2) Установить на Windows gvim74.exe
3) На Windows добавить в скрипт ничего не делающую строку, например комментарий. Редактором должен быть GVim.
4) Закоммитить скрипт с Windows в SVN-репо.
5) На первом сервере в /opt/scripts пропдейтиться так, чтобы увидеть изменения в скрипте.

Задача #35
1) Усложнить бэкапный скрипт так, чтобы ему не надо было перечислять какие сайты существуют - пусть сам выдирает их из конфига Апача. То есть при добавлении четвертого сайта в Апач, он автоматически должен бэкапить сразу все четыре.
2) Закоммитить скрипт в SVN-репозиторий
3) Усложнить бэкапный скрипт так, чтобы все сообщения он писал не echo'ом в консоль, а одновременно и в консоль и в syslog.
4) Закоммитить скрипт в SVN-репозиторий
5) Сломать скрипт, вписав в него какую-нибудь синтаксическую ошибку.
6) Закоммитить в репозиторий вместе с ошибкой :)
7) При помощи SVN-репозитория откатить скрипт до последней работающей версии.

Задача #36
1) Усложнить бэкапный скрипт так, чтобы пароли и логины в MySQL он знал не зарание, а сам умел определять какая CMS у сайта и где у нее конгфиг - оттуда и выдергивал данные доступа к базе.
2) Закоммитить скрипт в SVN-репо.

Задача #37
1) Настроить rsyslog первого сервера так, чтобы логи бэкапного скрипта писались не в общий файл /var/log/syslog, а в свой собственный /var/log/backup.log
2) Настроить сбор логов на первом сервере в том числе со второго сервера.
3) Поднять на этом сервере LogAnalyzer.

Задача #38
1) Усложнить бэкапный скрипт так, чтобы по завершении он еще запускал синхронизацию директорий /var/backups/www между обоими серверам. Для сихнронизации использовать rsync
2) Закоммитить скрипт в репо.
3) Переписать эту же задачу так, чтобы использовался не rsync, а lftp mirror.

Задача #39
1) Прочитать статью о файловой системе.
2) Прочитать статью о скедулерах.

Задача #40
1) На втором сервере поднять puppet.
2) Отдать паппету на управление файл /etc/passwd

Задача #41
1) Прочитать какие бывают init
2) Попробовать загрузиться в разные init-уровни
3) Перезагрузить сервер командой init
4) Выключить сервер командой init и затем включить.

Задача #42
1) Представить, что забыли пароль от root
2) Восстановить пароль, загрузив ядро с параметром init=/bin/bash или в single mode (а лучше и тем и тем способом для развития кругозора)

Задача #43
1) Разобраться чем аутентификация отличается от авторизации
2) Понять принципы работы PAM по этой и этой статьям.
3) Разобраться для чего нужен файл /etc/nsswitch.conf
4) Сделать авторизацию SSH не в files (/etc/passwd,/etc/shadow), а в MySQL. Files оставить как запасной вариант.

Задача #44
1) Написать на bash скрипт-демон в /opt/scrpts/my_daemon.sh, который:
a) отцепляется от STDIN,STDOUT,STDERR
b) меняет рабочую директорию на /
с) закрывает все дескрипторы файлов
d) в бесконечном цикле раз в минуту пишет в лог /var/log/my_daemon.log сообщение "I work already NNN minutes after restart", где NNN - количество минут, которые он выдирает из выхлопа команды uptime.

Задача #45
1) Создать init-скрипт в /etc/init.d/my_daemon с LSB-тэгами.
2) Попробовать стартануть и остановить скрипт /opt/scrpts/my_daemon.sh при помощи init-скрипта /etc/init.d/my_daemon
3) Попробовать стартануть, остановить и посмотреть статус скрипта правильным путем: при помощи команды "service"
4) Сделать так, чтобы этот демон загружался автоматически вместе с загрузкой операционной системы.

Задача #46
1) Переделать этот скрипт с SysVinit на systemd - теперь он находится не в /etc/init.d, а в /etc/systemd/system/ и имеет совершенно другую структуру.
3) Попробовать стартануть, остановить и посмотреть статус скрипта правильным путем для systemd: при помощи команды "systemctl"


Задача #47
1) Пройти любые курсы по сетям. Чтобы научиться работать с раутерами.
По результатам вы должны очень отчетливо понимать, что такое OSI, что такое TCP/IP (большинство протоколов с этого стэка), что такое NAT и что как формируется и работает раутинговая таблица.

Задача #48
1) Поставить на свой Windows Cygwin. Выберите пакеты python, vim, git, openssh + все, чем вы привыкли пользоваться на Linux.
2) Добавьте путь к бинарникам Cygwin'а в %PATH% Windows (где-то в свойствах Моего Компьютера - Дополнительно - быстродействие)
3) Запустите консоль cmd (внимание: запускать ее надо после того, как изменили %PATH%, а то она не будет знать про новый %PATH%)
4) Ну попробуйте теперь поработать на винде, как на линуксе - у вас появились утилиты ls, grep, wc, ssh и все такое :-)
5) Поставьте что-то удобное вместо cmd. Например ConEmu. У него есть quake-функция. Он может уезжать наверх и выезжать обратно по нажатию Ctrl+˜ (там где-то в меню включается).

Задача #49
1) Удалить все виртуалки
2) Удалить с Windows все VMware-продукты
3) Поставить VirtualBox вместо VMware
4) Поставить Vagrant (прямо на ваш Windows).
5) Создать директорию C:\VM\server1 и перейти в нее
6) Инициализировать здесь вагрантом новый конфиг Debian
7) Запустить вагрантом этот конфиг (пока еще в дефолтном его состоянии)
8) Открыть VirtualBox и убедиться, что была создана новая виртуалка
9) Остановите и удалите виртуалку. Дефолтная нам не нужна
10) Отрегулируйте конфиг: имя, 3 CPU, RAM 1Gb, проброс порта 22
11) Запустите ее и попробуйте присоединиться по SSH через putty (будет много трудностей с настройкой этой убогой сети Виртуалбокса - именно поэтому я не дал виртуалбокс в самом начале руководства) 

Задача #50
1) Поставьте на Cygwin Ansible.
2) Включите в Vagrantfile в самом конце провиженинг Ansible. Для начала, пусть Ansible автоматически установит curl на новой виртуалке.
3) Дополните Ansible важними вещами, которые будут делаться при запуске/создании новой виртуалки:
  установка apt-get: git, curl
  установка pyenv
  установка python3.6 при помощи pyenv
  делать python3.6 дефолтным глобально
  установка pip3-модулей: Logbook, paramiko, lxml
4) Создать с нуля виртуалку при помощи этой автоматизации. То есть вы даете только команду "vagrant up", а новосозданная виртуалка имеет все вышеперечисленное.

Задача #51
1) проверить свои знания в тесте "Системное администрирование Linux" на сайте RetraTech.

Задача #52 (опциональная)
1) Познакомиться с проектом LFS. После данного тьюториала, LFS пойдет на ура.

Мы начинаем учиться программировать на Python - это очень важное умение для любого IT-шника, включая сисадмина. На нем удобно писать себе скрипты. На нем удобно делать прототипирование приложений, на нам удобно жарить картошку даже.
Так, как сегодня очень много вакансий по BigData, то на пайтоне мы будем решать задачи BigData - заодно прокачаете и Python и будете себя уверено чувствовать в BigData.  На этом будущие системные администраторы могут остановиться и удариться в изучение чего-то, что по душе, параллельно ища первую работу.

Задача #52
1. Пройти базовые курсы Python.
Например, на CodeAcademy.
2. Скачайте себе хорошую подборочку книг: torrent.


Задача #53
чуть позже продолжу...
Пока для себя план просто скину, не обращайте внимание:
BigData for TCP/IP calls.

Each call has properties:
person
source IP-address
call type (SIP, H.323, ...)
call length
call server (server which served the call)

Compose event generator which stores events in Kafka (last 5 days)
Convert: Kafka --> Flume --> HDFS
Create Hive tables over HDFS
Do analytics with Hive requests
Store Hive-request results: Hive --> Scoop --> PostgreSQL 




______


Итак, вы закончили курс системного администрирования. На этом жизнь не останавливается. Дальше вам нужно решать - остаетесь ли вы сисадмином или уходите в программирование+DevOps.
Если интересно второе, то можете заглянуть (не делать, а быстро ознакомиться по диагонали) на мой пост , а затем вернуться сюда:
Программисты должны будут продолжить в заданном направлении:
Я дам еще одну задачку более низкого уровня - посложнее. Нужно будет сниффить траффик в несколько процессов и укладывать его в какой-нибудь IPC, например ZeroMQ. Вас также ждет одна задачка с употреблением SQL, одна с NoSQL и одна с MQ. Мы научимся правильно логировать и конфигурировать приложение как с файла, так и с zero-configuration. Кроме того, мы освоим написание веб-морды (на Django), REST API (на том же Django + API blueprint) и обновления баз данных при помощи migrations. Возможно, я включу еще GraphQL в программу.


[курсы, которые заслуживают внимания, но потребуют много времени и, возможно, денег]:
https://geekbrains.ru/professions/python_developer
https://www.edx.org/course/subject/computer-science/python

вот еще список очень годных ресурсов: https://habr.com/ru/post/156241/

